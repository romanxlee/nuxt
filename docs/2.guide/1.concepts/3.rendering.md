---
title: 'Режимы рендеринга'
description: 'Узнайте о разных режимах рендеринга, доступных в Nuxt.'
---

Nuxt поддерживает разные режимы рендеринга: [универсальный рендеринг](#universal-rendering), [рендеринг на стороне клиента](#client-side-rendering), а также предоставляет [гибридный рендеринг](#hybrid-rendering) и возможность рендерить ваше приложение на [пограничных CDN-серверах](#edge-side-rendering).

И браузер, и сервер могут интерпретировать код JavaScript для преобразования компонентов Vue.js в HTML элементы. Этот шаг называется **рендеринг**. Nuxt поддерживает как **универсальный**, так и **клиентский** рендеринг. У этих двух подходов есть преимущества и недостатки, которые мы рассмотрим.

По умолчанию Nuxt использует **универсальный рендеринг**, чтобы обеспечить лучший пользовательский опыт, производительность и оптимизировать индексацию поисковыми системами, но вы можете переключать режимы рендеринга в [одной строке конфигурации](/docs/api/nuxt-config#ssr).

## Универсальный Рендеринг

Когда браузер запрашивает URL-адрес с включенным универсальным (серверным + клиентским) рендерингом, сервер возвращает браузеру полностью отрисованную HTML-страницу. Независимо от того, была ли страница сгенерирована заранее и кэширована или отрисовывается на лету, в какой-то момент Nuxt запустил код JavaScript (Vue.js) в среде сервера, создав HTML-документ. Пользователи сразу получают контент нашего приложения, в отличие от рендеринга на стороне клиента. Этот шаг аналогичен традиционному **рендерингу на стороне сервера**, выполняемому приложениями PHP или Ruby.

Чтобы не потерять преимущества метода рендеринга на стороне клиента, такие как динамические интерфейсы и переходы страниц, Клиент (браузер) загружает код JavaScript, который запускается на Сервере в фоновом режиме после загрузки HTML-документа. Браузер интерпретирует его снова (отсюда и **универсальный рендеринг**), а Vue.js берет на себя управление документом и обеспечивает интерактивность.

Процесс, когда статичная страница становится интерактивной в браузере, называется "Гидратация".

Универсальный рендеринг позволяет Nuxt приложению обеспечить быструю загрузку страницы, сохраняя при этом преимущества рендеринга на стороне клиента. Более того, поскольку контент уже присутствует в HTML-документе, поисковые роботы могут индексировать его без дополнительных затрат.

![Пользователи могут получить доступ к статическому содержимому, когда HTML-документ загружен. Затем гидратация обеспечивает интерактивность страницы.](/assets/docs/concepts/rendering/ssr.svg)

**Преимущества рендеринга на стороне сервера:**
- **Производительность**: Пользователи могут получить немедленный доступ к содержимому страницы, поскольку браузеры могут отображать статический контент гораздо быстрее, чем контент, сгенерированный JavaScript. В то же время Nuxt сохраняет интерактивность веб-приложения, когда происходит процесс гидратации.
- **Поисковая оптимизация**: Универсальный рендеринг доставляет все HTML-содержимое страницы в браузер как классическое серверное приложение. Поисковые роботы могут напрямую индексировать содержимое страницы, что делает универсальный рендеринг отличным выбором для любого контента, который вы хотите быстро проиндексировать.

**Недостатки рендеринга на стороне сервера:**
- **Ограничения разработки:** Среды сервера и браузера не предоставляют одни и те же API, и может быть сложно написать код, который мог бы беспрепятственно выполняться на обеих сторонах. К счастью, Nuxt предоставляет рекомендации и специальные переменные, которые помогут вам определить, где выполняется фрагмент кода.
- **Стоимость:** Чтобы отображать страницы «на лету», должен быть запущен сервер. Это добавляет ежемесячные расходы, как и у любого традиционного сервера. Однако количество вызовов сервера значительно сокращается благодаря универсальному рендерингу, когда браузер берет на себя навигацию на стороне клиента. Снижение затрат возможно за счет использования [пограничного рендеринга](#edge-side-rendering).

Универсальный рендеринг очень гибок и может подойти практически для любого варианта использования и особенно подходит для любых контентно-ориентированных веб-сайтов: **блоги, маркетинговые веб-сайты, портфолио, сайты электронной коммерции и торговые площадки.**

::tip
Дополнительные примеры написания кода Vue без несоответствия гидратации смотрите в [документацию Vue](https://ru.vuejs.org/guide/scaling-up/ssr.html#hydration-mismatch).
::

::important
При импорте библиотеки, которая использует API браузера и имеет побочные эффекты, убедитесь, что импортирующий ее компонент вызывается только на стороне клиента. Бандлеры не обрабатывают импорт модулей, содержащих побочные эффекты.
::

## Рендеринг на стороне клиента

Из коробки, традиционное Vue.js приложение рендерится в браузере (или **на клиенте**). Затем Vue.js генерирует HTML-элементы после того, как браузер загрузит и спарсит весь JavaScript код, содержащий инструкции для создания текущего интерфейса.

![Пользователям приходится ждать, пока браузер загрузит, спарсит и выполнит JavaScript, прежде чем увидеть содержимое страницы.](/assets/docs/concepts/rendering/csr.svg)

**Преимущества рендеринга на стороне клиента:**
- **Скорость разработки**: При работе полностью на стороне клиента нам не нужно беспокоиться о совместимости кода с сервером, например, используя API только для браузера, такие как объект `window`.
- **Дешевле:** Запуск сервера увеличивает стоимость инфраструктуры, поскольку вам потребуется работать на платформе, поддерживающей JavaScript. Мы можем размещать клиентские приложения на любом статическом сервере с файлами HTML, CSS и JavaScript.
- **Оффлайн:** Поскольку код полностью выполняется в браузере, он может продолжать работать, даже если интернет недоступен.

**Недостатки рендеринга на стороне клиента:**
- **Производительность**: Пользователю приходится ждать, пока браузер загрузит, проанализирует и запустит файлы JavaScript. Это может занять некоторое время и повлиять на пользовательский опыт, в зависимости от сети для загрузки и устройства пользователя для парсинга и выполнения.
- **Поисковая оптимизация**: Индексирование и обновление контента, доставленного посредством рендеринга на стороне клиента, занимает больше времени, чем при обработке HTML-документа, отрисованного на сервере. Это связано с недостатком производительности, который мы обсуждали, поскольку поисковые роботы не будут ждать полной визуализации интерфейса при первой попытке индексировать страницу. Вашему контенту потребуется больше времени, чтобы отобразиться и обновиться на страницах результатов поиска с рендерингом полностью на стороне клиента.

Рендеринг на стороне клиента - хороший выбор для сильно интерактивных **веб приложений**, которые не нуждаются в индексации или которые пользователи посещают часто. Они могут использовать браузерное кеширование, чтобы пропустить этап загрузки при последующих посещениях, такие как **SaaS, приложения для бэк-офиса или онлайн-игры**.

Вы можете включить рендеринг только на стороне клиента с помощью Nuxt в вашем `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ssr: false
})
```

::note
Если вы успользуете `ssr: false`, вы должны расположить в `~/app/spa-loading-template.html` HTML-файл с некоторым HTML-кодом, который вы хотите использовать для рендеринга экрана загрузки, который будет отображаться до тех пор, пока ваше приложение не будет гидрировано.
:read-more{title="SPA Loading Template" to="/docs/api/configuration/nuxt-config#spaloadingtemplate"}
::

::tip{to="https://www.youtube.com/watch?v=7Lr0QTP1Ro8" icon="i-logos-youtube-icon" target="_blank"}
Посмотрите видео Александра Лихтера про **Создание чистого SPA с Nuxt!?**.
::

### Развертывание статичного приложения, отрисованного на стороне клиента

Если вы размещаете ваше приложение на [статичном хостинге](/docs/getting-started/deployment#static-hosting) с помощью команд `nuxi generate` или `nuxi build --prerender`, тогда по умолчанию, Nuxt будет рендерить каждую страницу как отдельный статичный HTML-файл.

Если вы используете рендеринг полностью на стороне клиента, тогда это может быть ненужно. Возможно, вам понадобится только один `index.html` файл, плюс запасные `200.html` и `404.html`, которые вы можете указать своему статическому веб-хосту для обслуживания всех запросов.

Чтобы добиться этого, мы можем поменять как пререндерятся маршруты. Просто добавьте это к [вашим hooks](/docs/api/advanced/hooks#nuxt-hooks-build-time) в вашем `nuxt.config.ts`:

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  hooks: {
    'prerender:routes' ({ routes }) {
      routes.clear() // Не создает никаких маршрутов (кроме значений по умолчанию)
    }
  },
})
```

Это создаст три файла:

- `index.html`
- `200.html`
- `404.html`

`200.html` и `404.html` могут быть полезны для используемого вами хостинг-провайдера.

## Гибридный рендеринг

Гибридный рендеринг допускает разные правила кэширования для каждого маршрута, используя **Route Rules**, и решает как сервер должен отвечать на новый запрос по заданному URL.

Раньше каждый маршрут/страница Nuxt приложения и сервер должны были использовать одинаковый режим рендеринга, универсальный или клиентский. В различных случаях некоторые страницы должны быть созданы во время сборки, в то время как другие должны быть отрисованы на клиенте. Например, подумайте о контентных сайтах с админ-частью. Каждая страница с контеном должна быть в первую очередь статической и генерироваться один раз, но админ-часть требует регистрации и ведет себя скорее как динамическое приложение.

Nuxt 3 включает в себя правила маршрутизации и поддержку гибридного рендеринга. Используя правила маршрутизации, вы можете определить правила для группы nuxt-маршрутов, меняя режим рендеринга или назначая стратегию кэширования, основанных на маршруте!

Nuxt-сервер будет автоматически регистрировать соответствующие middleware и оборачивать маршруты с обработчиками кэша, используя [Nitro caching layer](https://nitro.unjs.io/guide/cache).

```ts twoslash [nuxt.config.ts]
export default defineNuxtConfig({
  routeRules: {
    // Домашняя страница предварительно отрисовывается во время сборки
    '/': { prerender: true },
    // Страница продуктов создается по требованию, повторно проверяется в фоновом режиме, кэшируется до изменения ответа API
    '/products': { swr: true },
    // Страница продукта создается по требованию, повторно проверяется в фоновом режиме, кэшируется на один час (3600 секунд)
    '/products/**': { swr: 3600 },
    // Страница сообщений в блоге создается по требованию, повторно проверяется в фоновом режиме, кэшируется на CDN на один час (3600 секунд)
    '/blog': { isr: 3600 },
    // Страница сообщения в блоге создается по требованию до следующего развертывания, кэшируется на CDN
    '/blog/**': { isr: true },
    // Панель управления администратора рендерится только на стороне клиента
    '/admin/**': { ssr: false },
    // Добавляет CORS-заголовки на маршрутах API
    '/api/**': { cors: true },
    // Перенаправляет legacy URL-адреса
    '/old-page': { redirect: '/new-page' }
  }
})
```

### Правила маршрутизации

Вы можете использовать следующие свойства::
- `redirect: string`{lang=ts} - Определяет перенаправления на стороне сервера.
- `ssr: boolean`{lang=ts} - Отключает рендеринг на стороне сервера для разделов вашего приложения и делает их полностью SPA с помощью `ssr: false`.
- `cors: boolean`{lang=ts} - Автоматически добавляет cors-заголовки с `cors: true` - вы можете настроить вывод, переопределив с помощью `headers`.
- `headers: object`{lang=ts} - Добавьте определенные заголовки в разделы вашего сайта, например, в ваши ресурсы.
- `swr: number | boolean`{lang=ts} - Добавьте заголовки кэша к ответу сервера и кэшируйте его на сервере или обратном прокси-сервере для настраиваемого TTL (time to live - времени жизни). Настройка Nitro `node-server` способна кэшировать полный ответ. По истечении срока жизни (TTL) будет отправлен кэшированный ответ, а страница будет перегенерирована в фоновом режиме. Если импользуется true, будет добавлен заголовок `stale-while-revalidate` без MaxAge.
- `isr: number | boolean`{lang=ts} - Поведение схоже с `swr`, за исключением того, что мы можем добавить ответ в кеш CDN на платформах, которые это поддерживают (в настоящее время Netlify или Vercel). Если используется `true`, контент сохраняется до следующего развертывания внутри CDN.
- `prerender: boolean`{lang=ts} - Предварительно отрисовывает маршруты во время сборки и включает их в сборку как статические ресурсы.
- `experimentalNoScripts: boolean`{lang=ts} - Отключает рендеринг скриптов Nuxt и подсказок ресурсов JS для разделов вашего сайта.
- `appMiddleware: string | string[] | Record<string, boolean>`{lang=ts} - Позволяет вам определить middleware, которое должно или не должно запускаться для путей к страницам в части Vue вашего приложения (то есть не для ваших маршрутов Nitro).

По возможности правила маршрутизации будут автоматически применяться к собственным правилам платформы развертывания для достижения оптимальной производительности (в настоящее время поддерживаются Netlify и Vercel).

::important
Обратите внимание, что гибридный рендеринг недоступен при использовании [`nuxt generate`](/docs/api/commands/generate).
::

**Примеры:**

::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Vercel ISR
  to: https://github.com/danielroe/nuxt-vercel-isr
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Пример Nuxt-приложения с гибридным рендерингом, развернутом на Vercel.
  ::
::

## Пограничный рендеринг

Пограничный рендеринг (Edge-Side Rendering - ESR) — это мощная функция, представленная в Nuxt 3, которая позволяет отображать ваше приложение Nuxt ближе к вашим пользователям через пограничные серверы сети доставки контента (CDN). Используя ESR, вы можете обеспечить повышенную производительность и сокращение задержек, тем самым обеспечивая улучшенный пользовательский опыт.

При использовании ESR процесс рендеринга переносится на «край» сети — пограничные серверы CDN. Обратите внимание, что ESR — это скорее цель развертывания, чем реальный режим рендеринга.

Когда делается запрос страницы, вместо того, чтобы дойти до исходного сервера, он перехватывается ближайшим пограничным сервером. Этот сервер генерирует HTML для страницы и отправляет его обратно пользователю. Этот процесс минимизирует физическое расстояние, которое должны пройти данные, **уменьшая задержку и ускоряя загрузку страницы**.

Пограничный рендеринг возомжен, благодаря [Nitro](https://nitro.unjs.io), [серверному движку](/docs/guide/concepts/server-engine), который обеспечивает работу Nuxt 3. Он предлагает кроссплатформенную поддержку Node.js, Deno, Cloudflare Workers и других.

Текущие платформы, на которых вы можете использовать ESR:
- [Cloudflare Pages](https://pages.cloudflare.com) с нулевой конфигурацией с использованием git-интеграции и команды `nuxt build`
- [Vercel Edge Functions](https://vercel.com/features/edge-functions) с использованием команды `nuxt build` и переменной окружения `NITRO_PRESET=vercel-edge`
- [Netlify Edge Functions](https://www.netlify.com/products/#netlify-edge-functions) с использованием команды `nuxt build` и переменной окружения `NITRO_PRESET=netlify-edge`

Обратите внимание, что **Гибридный рендеринг** можно использовать при использовании Пограничного рендеринга с правилами маршрутизации.

Вы можете изучить примеры с открытым исходным кодом, развернутые на некоторых платформах, упомянутых выше:
::card-group
  ::card
  ---
  icon: i-simple-icons-github
  title: Nuxt Todos Edge
  to: https://github.com/atinux/nuxt-todos-edge
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Приложение со списком дел с аутентификацией пользователей, SSR и SQLite.
  ::
  ::card
  ---
  icon: i-simple-icons-github
  title: Atinotes
  to: https://github.com/atinux/atinotes
  target: _blank
  ui.icon.base: text-black dark:text-white
  ---
  Редактируемый сайт с универсальным рендерингом на CloudFlare KV.
  ::
::

<!-- TODO: link to templates with ESR category for examples -->
